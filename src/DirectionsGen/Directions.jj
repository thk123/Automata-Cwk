options {	STATIC = false;	IGNORE_CASE = true;	DEBUG_PARSER = true;
}PARSER_BEGIN(Directions)	class Directions	{	  static int i =0;		public static void main(String[] args) throws ParseException, UndefinedLocationException, PlaceAlreadyDefinedException		{			Directions parser = new Directions(System.in);			try			{				parser.Start();			}			catch(ParseException e)			{				System.err.println("[LEXING ERROR]" + e.getMessage());			}			catch(UndefinedLocationException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.locationName + "\" not defined");			}			catch(PlaceAlreadyDefinedException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.locationName + "\" defined already");			}			catch(SelfReferentialRelationException e)			{				System.err.println("[PARSING ERROR] Cannot perform self referential relation with location \"" + e.locationName + "\""); 			}		}	}	class Location	{	  public String locationName;		java.util.HashMap<String, Location > northLocations;		java.util.HashMap<String, Location > southLocations;		java.util.HashMap<String, Location > westLocations;		java.util.HashMap<String, Location > eastLocations;	  public Location(String locName)	  {	    locationName = locName;	    northLocations = new java.util.HashMap<String, Location >();	    westLocations = new java.util.HashMap<String, Location >();	    eastLocations = new java.util.HashMap<String, Location >();	    southLocations = new java.util.HashMap<String, Location >();	  }	  public void AddNorthLocation(Location location) throws IncorrectLocationException	  {			if(southLocations.containsKey(location.locationName))			{				throw new IncorrectLocationException(this, location, Direction.NORTH);			}			else			{				northLocations.put(location.locationName, location);			}	  }	  public void AddSouthLocation(Location location) throws IncorrectLocationException	  {			if(northLocations.containsKey(location.locationName))			{				throw new IncorrectLocationException(this, location, Direction.SOUTH);			}			else			{				southLocations.put(location.locationName, location);			}	  }	}	class UndefinedLocationException extends Exception	{	  	public String locationName;		public UndefinedLocationException(String locationName)		{			  super();			  this.locationName = locationName;		}	}	class PlaceAlreadyDefinedException extends Exception	{		public String locationName;		public PlaceAlreadyDefinedException(String locationName)		{		  	super();		  	this.locationName = locationName;		}		}	class IncorrectLocationException extends Exception	{		public IncorrectLocationException(Location aLocation, Location bLocation, Direction direction)		{		}		}	class SelfReferentialRelationException extends Exception	{	  	public String locationName;		public SelfReferentialRelationException(String location)		{			locationName = location;		}	}	enum Direction	{	  NORTH,	  SOUTH,	  EAST,	  WEST	}	PARSER_END(Directions)void Start() throws UndefinedLocationException,					PlaceAlreadyDefinedException,					SelfReferentialRelationException :{  java.util.HashMap<String, Location> locations;}{  {   	locations = new java.util.HashMap<String, Location >();  }  (        (PlaceDecleration(locations) | PlaceRelation(locations) ) < LINETERMINATOR >    {    }  )+  < EOF >  }void PlaceDecleration(java.util.HashMap<String, Location > locations) throws PlaceAlreadyDefinedException:{  String placeName;}{  "I see "  placeName = PlaceDefinition()  {    placeName = placeName.toLowerCase();    if(locations.containsKey(placeName))    {		throw new PlaceAlreadyDefinedException(placeName);    }    else    {		locations.put(placeName, new Location(placeName));	}  }  (    < LISTSEPERATOR >    placeName = PlaceDefinition()    {      	placeName = placeName.toLowerCase();		locations.put(placeName, new Location(placeName));    }  )*  }void PlaceRelation(java.util.HashMap definedLocations) throws UndefinedLocationException,																SelfReferentialRelationException :{  	String placeA;  	String placeB;}{  	placeA = PlaceDefinition() (" is "  							| MultiplePlaceListRelation(definedLocations) " are ")  	< DIRECTION > " of " placeB = PlaceDefinition() (MultiplePlaceListRelation(definedLocations))?  	{   		if(!definedLocations.containsKey(placeA.toLowerCase()) || !definedLocations.containsKey(placeB.toLowerCase()))  		{  			System.out.println("Location not found");  	  		if(!definedLocations.containsKey(placeA.toLowerCase()))  	  		{    	  			throw new UndefinedLocationException(placeA);  	  		}  	  		else  	  		{				throw new UndefinedLocationException(placeB);  	  		}  		}  		else  		{  	 		System.out.println("Both locations found");  	 		if(placeA.toLowerCase().equals(placeB.toLowerCase()))  	 		{				throw new SelfReferentialRelationException(placeA);  	 		}  	 	//locations.get(placeA.placeName).		}	}  }//Read multiple places and throw an error if any one of them not foundvoid MultiplePlaceListRelation(java.util.HashMap locations) throws UndefinedLocationException :{	String placeName;}{  	(    	< LISTSEPERATOR >    	placeName = PlaceDefinition()    	{			if(!locations.containsKey(placeName.toLowerCase()))			{				throw new UndefinedLocationException(placeName);			}    	}  	)+}SKIP:{ 	"\r" | "\n" | "\r\n"} TOKEN :{  	< DIRECTION : "NORTH" | "SOUTH" | "EAST" | "WEST" >}TOKEN :{  	< LISTSEPERATOR : ", " | " and " >}String PlaceDefinition() :{ 	Token t;  	String placeName;}{	< PLACESTART >	t = < PLACE >	{	  placeName = t.image;	}	{	  return placeName;	}}  TOKEN :{ 	< PLACESTART : "THE " > }TOKEN :{  	< PLACE : "[" (["a" - "z"] | " ")+ "]" | (["a" - "z"])+>}TOKEN :{  	< LINETERMINATOR : "." | ";" >}
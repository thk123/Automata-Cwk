options {	STATIC = false;	IGNORE_CASE = true;	DEBUG_PARSER = true;
}PARSER_BEGIN(Directions)	import java.util.*;	class Directions	{	  	static int i = 0;		public static void main(String[] args) throws ParseException, UndefinedLocationException, PlaceAlreadyDefinedException		{		  	java.util.HashMap<String, Location> locations = new java.util.HashMap<String, Location>(); 			Directions parser = new Directions(System.in);			try			{				parser.Start(locations);			}			catch(ParseException e)			{				System.err.println("[PARSING ERROR]" + e.getMessage());			}			catch(TokenMgrError e)			{				System.err.println("[LEXING ERROR] " + e.getMessage());			}			catch(UndefinedLocationException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.locationName + "\" not defined");			}			catch(PlaceAlreadyDefinedException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.locationName + "\" defined already");			}			catch(SelfReferentialRelationException e)			{				System.err.println("[PARSING ERROR] Cannot perform self referential relation with location \"" + e.locationName + "\""); 			}			catch(IncorrectLocationException e)			{				Direction oppositeDirection = Direction.east;				switch(e.dir)				{					case east:						oppositeDirection = Direction.west;						break;					case west:						oppositeDirection = Direction.east;						break;					case north:						oppositeDirection = Direction.south;						break;					case south:						oppositeDirection = Direction.north;						break;						}				System.err.println("[PARSING ERROR] Location \"" + e.locA + "\" cannot be both " + e.dir.toString() + " and " + oppositeDirection.toString() + " of \"" + e.locB + "\"");				}			System.out.println("Number of defined locations: " + locations.size());			String[][] distances = new String[locations.size()][locations.size()];			String[] sortedNames= new String[locations.size()];			int row = 0;			int column = 0;			for(Location locationAEntry : locations.values())			{				for(Location locationBEntry : locations.values())				{				  	System.out.println("Distance at " + row + ", " + column + " is " + locationAEntry.getDistance(locationBEntry));					distances[row][column] = locationAEntry.getDistance(locationBEntry);					++row;				}				row = 0;				sortedNames[column] = locationAEntry.locationName;				++column;			}						System.out.print("\t");			for(String locationName : sortedNames)			{				System.out.print(locationName + "\t");			}			System.out.println();						for(int i = 0; i < locations.size(); ++i)			{				System.out.print(sortedNames[i] + "\t");				for(int j = 0; j < locations.size(); ++j)				{					System.out.print(distances[i][j] + "\t");				}				System.out.println();			}		}	}	class Location	{	  	public String locationName;		java.util.HashMap<String, Location > northLocations;		java.util.HashMap<String, Location > southLocations;		java.util.HashMap<String, Location > westLocations;		java.util.HashMap<String, Location > eastLocations;		java.util.HashMap<Location, LocationRelation > relations;	  	public Location(String locName)	  	{		    locationName = locName;		    northLocations = new java.util.HashMap<String, Location >(); //all locations defined to be north of this location either directly or transitively		    westLocations = new java.util.HashMap<String, Location >();		    eastLocations = new java.util.HashMap<String, Location >();		    southLocations = new java.util.HashMap<String, Location >();		    relations = new java.util.HashMap<Location, LocationRelation >();	  	}	  	public void AddLocationRelation(Location l, Direction d, float distance) throws IncorrectLocationException 	  	{			if(relations.containsKey(l))			{			  	System.out.println("Location Relation already exists, modifying");				LocationRelation existingRelation = relations.get(l);				try				{  					existingRelation.setDirection(d, distance);				}				catch(IncorrectLocationException e)				{					throw new IncorrectLocationException(this, l, d);				}			}			else			{			  	LocationRelation newRelation = new LocationRelation();			  	newRelation.setDirection(d,distance);				relations.put(l, newRelation);			}	  	}		public void AddNorthLocation(Location location) throws IncorrectLocationException		{			if(southLocations.containsKey(location.locationName))			{				throw new IncorrectLocationException(this, location, Direction.north);			}			else			{			  	HashMap<String, Location> impliedNorthernLocations = location.GetAllLocations(Direction.north);				northLocations.putAll(impliedNorthernLocations);			  	for(Map.Entry<String, Location> locationEntry : impliedNorthernLocations.entrySet())				{					System.out.println("Adding north location - " + locationEntry.getKey() + " to location " + locationName);				}			}		}			public void AddSouthLocation(Location location) throws IncorrectLocationException		{			if(northLocations.containsKey(location.locationName))			{				throw new IncorrectLocationException(this, location, Direction.south);			}			else			{			  	HashMap<String, Location> impliedSouthernLocations = location.GetAllLocations(Direction.south);			  	southLocations.putAll(impliedSouthernLocations);			  	for(Map.Entry<String, Location> locationEntry : impliedSouthernLocations.entrySet())				{					System.out.println("Adding south location - " + locationEntry.getKey() + " to location " + locationName);				}			}		}		public void AddEastLocation(Location location) throws IncorrectLocationException		{		 	if(westLocations.containsKey(location.locationName))		 	{				throw new IncorrectLocationException(this, location, Direction.east);			}			else			{				eastLocations.putAll(location.GetAllLocations(Direction.east));				}		}		public void AddWestLocation(Location location) throws IncorrectLocationException		{		 	if(eastLocations.containsKey(location.locationName))		 	{				throw new IncorrectLocationException(this, location, Direction.west);			}			else			{				westLocations.putAll(location.GetAllLocations(Direction.west));				}		}		//Return all the locations (including this one) in a given direction including transitivity		public HashMap<String, Location> GetAllLocations(Direction direction)		{			HashMap<String, Location> locationsInDirection = new HashMap<String, Location>();			locationsInDirection.put(locationName, this);			switch(direction)			{				case north:					for(Location northLocation : northLocations.values())					{						locationsInDirection.putAll(northLocation.GetAllLocations(direction));					}				break;				case south:					for(Location southLocation : southLocations.values())					{						locationsInDirection.putAll(southLocation.GetAllLocations(direction));					}				break;				case east:					for(Location eastLocation : eastLocations.values())					{						locationsInDirection.putAll(eastLocation.GetAllLocations(direction));					}				break;				case west:					for(Location westLocation : westLocations.values())					{						locationsInDirection.putAll(westLocation.GetAllLocations(direction));					}				break;			}			return locationsInDirection;		} 		public static void DefineRelation(ArrayList<Location> locationAs, ArrayList<Location> locationBs, Direction relation, float distance) throws IncorrectLocationException		{			switch(relation)			{				case north:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is north of bLocation							aLocation.AddSouthLocation(bLocation);							bLocation.AddNorthLocation(aLocation);							aLocation.AddLocationRelation(bLocation, relation, distance);							bLocation.AddLocationRelation(aLocation, relation, distance);						}					}				break;				case south:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is south of bLocation							aLocation.AddNorthLocation(bLocation);							bLocation.AddSouthLocation(aLocation);							aLocation.AddLocationRelation(bLocation, relation, distance);							bLocation.AddLocationRelation(aLocation, relation, distance);						}					}				break;				case east:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is east of bLocation							aLocation.AddWestLocation(bLocation);							bLocation.AddEastLocation(aLocation);							aLocation.AddLocationRelation(bLocation, relation, distance);							bLocation.AddLocationRelation(aLocation, relation, distance);						}					}				break;				case west:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is west of bLocation							aLocation.AddEastLocation(bLocation);							bLocation.AddWestLocation(aLocation);							aLocation.AddLocationRelation(bLocation, relation, distance);							bLocation.AddLocationRelation(aLocation, relation, distance);						}					}				break;			}		}		public String getDistance(Location otherLocation)		{			if(otherLocation.equals(this))			{				return "0";			}			else			{				if(relations.containsKey(otherLocation))				{					LocationRelation relation = relations.get(otherLocation);					float distance = relation.getDistance();					if(distance == LocationRelation.UNDEFINEDDISTANCE)					{						return "unknown";					}					else					{						return Float.toString(distance);					}				}				else				{					return "unknown";				}			}		}		public int hashCode()		{			return locationName.hashCode();		}		public boolean equals(Location other)		{			return this.locationName == other.locationName;		}	}	class LocationRelation	{	  	public static final float UNDEFINEDDISTANCE = -1.0f;		private float northSouthDistance; //-ve equals south		private float eastWestDistance; //-ve equals west		private DirectionVector directionVector;		public LocationRelation()		{			directionVector = new DirectionVector();			northSouthDistance = 0.0f;			eastWestDistance = 0.0f;		}		public DirectionVector getDirection()		{		  	return directionVector;		}		public void setDirection(Direction d, float distance) throws IncorrectLocationException		{			switch(d)			{				case north:				{					if(directionVector.northSouth == Direction.south)					{						throw new IncorrectLocationException();					}					else					{						directionVector.northSouth = Direction.north;						northSouthDistance = distance;					}				}				break;				case south:				{					if(directionVector.northSouth == Direction.north)					{						throw new IncorrectLocationException();					}					else					{						directionVector.northSouth = Direction.south;						northSouthDistance = -distance;					}				}				break;				case east:				{					if(directionVector.eastWest == Direction.west)					{						throw new IncorrectLocationException();					}					else					{						directionVector.eastWest = Direction.east;						eastWestDistance = distance;					}				}				break;				case west:				{					if(directionVector.northSouth == Direction.east)					{						throw new IncorrectLocationException();					}					else					{						directionVector.eastWest = Direction.west;						eastWestDistance = -distance;					}				}				break;					}		}				public float getDistance()		{			if(directionVector.wellDefined())			{				return Math.abs(northSouthDistance) + Math.abs(eastWestDistance);			}			else			{				return UNDEFINEDDISTANCE;					}		}	}	class DirectionVector	{		public Direction northSouth;		public Direction eastWest;		public DirectionVector()		{			northSouth = Direction.undefined;			eastWest = Direction.undefined;		}				public boolean wellDefined()		{			return northSouth != Direction.undefined && eastWest != Direction.undefined;		}	}	  	class UndefinedLocationException extends Exception	{	  	public String locationName;		public UndefinedLocationException(String locationName)		{			  super();			  this.locationName = locationName;		}	}	class PlaceAlreadyDefinedException extends Exception	{		public String locationName;		public PlaceAlreadyDefinedException(String locationName)		{		  	super();		  	this.locationName = locationName;		}		}	class IncorrectLocationException extends Exception	{	  	public String locA;	  	public String locB;	  	public Direction dir;		public IncorrectLocationException()		{			locA = "Not set";			locB = "Not set";			dir = Direction.undefined;		}	  			public IncorrectLocationException(Location aLocation, Location bLocation, Direction direction)		{			locA = aLocation.locationName;			locB = bLocation.locationName;			dir = direction;		}			}	class SelfReferentialRelationException extends Exception	{	  	public String locationName;		public SelfReferentialRelationException(String location)		{			locationName = location;		}	}	enum Direction	{		north,		south,		east,		west,		undefined;		boolean isOpposite(Direction a, Direction b)		{			return (a == north && b == south) ||					(a == south && b == north) ||					(a == east && b == west) ||					(a == west && b == east);		}	}	enum DistanceUnit	{		m,		km,		miles	}	PARSER_END(Directions)void Start(java.util.HashMap<String, Location> locations) throws 	UndefinedLocationException, 		//Used an undefined location in a relation																	PlaceAlreadyDefinedException, 		//Defined a location twice																	SelfReferentialRelationException,	//Made a relation between same place (eg A is north of A)																	IncorrectLocationException :		//Made an invalid relation (eg A is north of B & B is north of A){}{  	(        	(PlaceDecleration(locations) 	//Take either a place deceleration (eg I see the A)    	| PlaceRelation(locations) ) 	//Or a place relation (eg the A is north of the B)    	< LINETERMINATOR > 				//Followed by a line terminator (eg .)    	{    	}  	)+  	< EOF >}void PlaceDecleration(java.util.HashMap<String, Location > locations) throws PlaceAlreadyDefinedException:{  	String placeName;}{  	"I see "  	placeName = PlaceDefinition()  	{    	if(locations.containsKey(placeName))    	{			throw new PlaceAlreadyDefinedException(placeName);    	}    	else    	{			locations.put(placeName, new Location(placeName));		}  	}  	(    	< LISTSEPERATOR >    	placeName = PlaceDefinition()    	{			locations.put(placeName, new Location(placeName));    	}  	)*  }void PlaceRelation(java.util.HashMap<String, Location> definedLocations) throws UndefinedLocationException,																				SelfReferentialRelationException,																				IncorrectLocationException :{  	String placeA;  	String placeB;  	ArrayList<String> aLocations = null;  	ArrayList<String> bLocations = null;  	Token directionToken;  	float distance = 1.0f;}{  	placeA = PlaceDefinition() (" is " //take either one place followed by is  			(distance = Distance())?  			    			| aLocations = MultiplePlaceListRelation(definedLocations) " are ") //or multiple followed by are  			directionToken = < DIRECTION > //Take a direction  			" of " placeB = PlaceDefinition() (bLocations = MultiplePlaceListRelation(definedLocations))? //of one or more places  	{  	  	// Initalise (if required) a and b lists and add at least one place to them  	  	System.out.println(Float.toString(distance));  	  	if(aLocations == null)  	  	{			aLocations = new ArrayList<String>();  	  	}  	  	aLocations.add(placeA);  	  	if(bLocations == null)  	  	{			bLocations = new ArrayList<String>();  	  	}  	  	bLocations.add(placeB);		//Check all locations exist in list A  	  	for(String location : aLocations)  	  	{			if(!definedLocations.containsKey(location.toLowerCase()))			{				throw new UndefinedLocationException(location);			}  	  	}		//Check all locations exist in list B		for(String location : bLocations)		{			if(!definedLocations.containsKey(location.toLowerCase()))			{				throw new UndefinedLocationException(location);			}		}  	  	 		System.out.println("All locations found");		//Check to see if any location is in both lists		for(String aLocation : aLocations)		{		  	for(String bLocation : bLocations)		  	{				if(aLocation.equals(bLocation))				{					throw new SelfReferentialRelationException(aLocation);				}		  	}		}		System.out.println("No location in both lists");		//Since all the locations are defined, we can now find them in our map of locations		ArrayList<Location> locationListA = new ArrayList<Location>();		ArrayList<Location> locationListB = new ArrayList<Location>();		for(String aLocation : aLocations)		{			locationListA.add(definedLocations.get(aLocation));		}		for(String bLocation : bLocations)		{			locationListB.add(definedLocations.get(bLocation));		} 		//Calculate the location entered by the user		Direction dir = Direction.valueOf(directionToken.image);		System.out.println(dir.toString());		//Define a location between all of the locations in List A with all of the locations in list B		Location.DefineRelation(locationListA, locationListB, dir, distance);	}  }//Read multiple places and throw an error if any one of them not foundArrayList<String> MultiplePlaceListRelation(java.util.HashMap locations) throws UndefinedLocationException :{	String placeName;	ArrayList<String> places = new ArrayList<String>();}{  	(    	< LISTSEPERATOR >    	placeName = PlaceDefinition()    	{			if(!locations.containsKey(placeName.toLowerCase()))			{				throw new UndefinedLocationException(placeName);			}			else			{				places.add(placeName);			}    	}  	)+  	{  	  	return places;  	}}float Distance() :{  Token distanceToken;  Token scaleToken;}{	distanceToken = < DISTANCE >	scaleToken = < MEASUREUNIT >	{		float distance = Float.parseFloat(distanceToken.image);		DistanceUnit dUnit = DistanceUnit.valueOf(scaleToken.image);		float factor = 0.0f;		switch(dUnit)		{			case m:				factor = 1.0f;			break;			case km:				factor = 1000.0f;			break;			case miles:				factor = 1609.0f;			break;						}		distance *= factor; //put the distance in to meters		return distance;	}}SKIP:{ 	"\r" | "\n" | "\r\n" | " "} TOKEN :{  	< DIRECTION : "NORTH" | "SOUTH" | "EAST" | "WEST" >}TOKEN :{	< MEASUREUNIT : "m" | "km" | "miles" >}TOKEN :{	< DISTANCE : (["0"-"9"])+ (["."] (["0"-"9"])+ )? > //one or more digits followed by 0 or 1 dot followed by some digits  }TOKEN :{  	< LISTSEPERATOR : ", " | " and " >}String PlaceDefinition() :{ 	Token t;  	String placeName = "";}{  	< PLACESTART >  	(  		(			t = < PLACECHAR > 			{				placeName += t.image; 			}		)+		|		(		 	< COMPLEXPLACESTART > (  				t = < COMPLEXPLACECHAR >				{			  		placeName += t.image;				}						)+		< COMPLEXPLACEEND > )	)	{	  return placeName.toLowerCase();	}}  TOKEN :{ 	< PLACESTART : "THE " > }TOKEN: //read a character or a space for a place name{	< PLACECHAR:  ( ["a" - "z"] | " ")  >}< READING_COMPLEX > TOKEN: //read a character or a space for a place name{	< COMPLEXPLACECHAR:  ( ["a" - "z"] | " ")  >}TOKEN:  //marks the begining of a place name with a keyword in{	< COMPLEXPLACESTART : "[" > : READING_COMPLEX}< READING_COMPLEX > TOKEN: //marks the end of a place name with a keyword in{	< COMPLEXPLACEEND : "]"  > :  DEFAULT }TOKEN :{  	< LINETERMINATOR : "." | ";" >}
options {	STATIC = false;	IGNORE_CASE = true;	DEBUG_PARSER = true;
}PARSER_BEGIN(Directions)	import java.util.*;	class Directions	{	  	static int i = 0;		public static void main(String[] args) throws ParseException, UndefinedLocationException, PlaceAlreadyDefinedException		{		  	java.util.HashMap<String, Location> locations = new java.util.HashMap<String, Location>(); 			Directions parser = new Directions(System.in);			try			{				parser.Start(locations);			}			catch(ParseException e)			{				System.err.println("[PARSING ERROR]" + e.getMessage());			}			catch(TokenMgrError e)			{				System.err.println("[LEXING ERROR] " + e.getMessage());			}			catch(UndefinedLocationException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.locationName + "\" not defined");			}			catch(PlaceAlreadyDefinedException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.locationName + "\" defined already");			}			catch(SelfReferentialRelationException e)			{				System.err.println("[PARSING ERROR] Cannot perform self referential relation with location \"" + e.locationName + "\""); 			}			catch(IncorrectLocationException e)			{				Direction oppositeDirection = Direction.east;				switch(e.dir)				{					case east:						oppositeDirection = Direction.west;						break;					case west:						oppositeDirection = Direction.east;						break;					case north:						oppositeDirection = Direction.south;						break;					case south:						oppositeDirection = Direction.north;						break;						}				System.err.println("[PARSING ERROR] Location \"" + e.locA + "\" cannot be both " + e.dir.toString() + " and " + oppositeDirection.toString() + " of \"" + e.locB + "\"");				}			System.out.print("[");			for(String locationName : locations.keySet())			{				System.out.println(locationName + ": ");			}			System.out.print("]");		}	}	class Location	{	  	public String locationName;		java.util.HashMap<String, Location > northLocations;		java.util.HashMap<String, Location > southLocations;		java.util.HashMap<String, Location > westLocations;		java.util.HashMap<String, Location > eastLocations;	  	public Location(String locName)	  	{		    locationName = locName;		    northLocations = new java.util.HashMap<String, Location >(); //all locations defined to be north of this location either directly or transitively		    westLocations = new java.util.HashMap<String, Location >();		    eastLocations = new java.util.HashMap<String, Location >();		    southLocations = new java.util.HashMap<String, Location >();	  	}		public void AddNorthLocation(Location location) throws IncorrectLocationException		{			if(southLocations.containsKey(location.locationName))			{				throw new IncorrectLocationException(this, location, Direction.north);			}			else			{			  	HashMap<String, Location> impliedNorthernLocations = location.GetAllLocations(Direction.north);				northLocations.putAll(impliedNorthernLocations);			  	for(Map.Entry<String, Location> locationEntry : impliedNorthernLocations.entrySet())				{					System.out.println("Adding north location - " + locationEntry.getKey() + " to location " + locationName);				}			}		}			public void AddSouthLocation(Location location) throws IncorrectLocationException		{			if(northLocations.containsKey(location.locationName))			{				throw new IncorrectLocationException(this, location, Direction.south);			}			else			{			  	HashMap<String, Location> impliedSouthernLocations = location.GetAllLocations(Direction.south);			  	southLocations.putAll(impliedSouthernLocations);			  	for(Map.Entry<String, Location> locationEntry : impliedSouthernLocations.entrySet())				{					System.out.println("Adding south location - " + locationEntry.getKey() + " to location " + locationName);				}			}		}		public void AddEastLocation(Location location) throws IncorrectLocationException		{		 	if(westLocations.containsKey(location.locationName))		 	{				throw new IncorrectLocationException(this, location, Direction.east);			}			else			{				eastLocations.putAll(location.GetAllLocations(Direction.east));				}		}		public void AddWestLocation(Location location) throws IncorrectLocationException		{		 	if(eastLocations.containsKey(location.locationName))		 	{				throw new IncorrectLocationException(this, location, Direction.west);			}			else			{				westLocations.putAll(location.GetAllLocations(Direction.west));				}		}		//Return all the locations (including this one) in a given direction including transitivity		public HashMap<String, Location> GetAllLocations(Direction direction)		{			HashMap<String, Location> locationsInDirection = new HashMap<String, Location>();			locationsInDirection.put(locationName, this);			switch(direction)			{				case north:					for(Location northLocation : northLocations.values())					{						locationsInDirection.putAll(northLocation.GetAllLocations(direction));					}				break;				case south:					for(Location southLocation : southLocations.values())					{						locationsInDirection.putAll(southLocation.GetAllLocations(direction));					}				break;				case east:					for(Location eastLocation : eastLocations.values())					{						locationsInDirection.putAll(eastLocation.GetAllLocations(direction));					}				break;				case west:					for(Location westLocation : westLocations.values())					{						locationsInDirection.putAll(westLocation.GetAllLocations(direction));					}				break;			}			return locationsInDirection;		} 		public static void DefineRelation(ArrayList<Location> locationAs, ArrayList<Location> locationBs, Direction relation) throws IncorrectLocationException		{			switch(relation)			{				case north:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is north of bLocation							aLocation.AddSouthLocation(bLocation);							bLocation.AddNorthLocation(aLocation);						}					}				break;				case south:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is south of bLocation							aLocation.AddNorthLocation(bLocation);							bLocation.AddSouthLocation(aLocation);						}					}				break;				case east:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is east of bLocation							aLocation.AddWestLocation(bLocation);							bLocation.AddEastLocation(aLocation);						}					}				break;				case west:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is west of bLocation							aLocation.AddEastLocation(bLocation);							bLocation.AddWestLocation(aLocation);						}					}				break;			}		}	}	class UndefinedLocationException extends Exception	{	  	public String locationName;		public UndefinedLocationException(String locationName)		{			  super();			  this.locationName = locationName;		}	}	class PlaceAlreadyDefinedException extends Exception	{		public String locationName;		public PlaceAlreadyDefinedException(String locationName)		{		  	super();		  	this.locationName = locationName;		}		}	class IncorrectLocationException extends Exception	{	  	public String locA;	  	public String locB;	  	public Direction dir;		public IncorrectLocationException(Location aLocation, Location bLocation, Direction direction)		{			locA = aLocation.locationName;			locB = bLocation.locationName;			dir = direction;		}			}	class SelfReferentialRelationException extends Exception	{	  	public String locationName;		public SelfReferentialRelationException(String location)		{			locationName = location;		}	}	enum Direction	{		north,		south,		east,		west	}	PARSER_END(Directions)void Start(java.util.HashMap<String, Location> locations) throws 	UndefinedLocationException, 		//Used an undefined location in a relation																	PlaceAlreadyDefinedException, 		//Defined a location twice																	SelfReferentialRelationException,	//Made a relation between same place (eg A is north of A)																	IncorrectLocationException :		//Made an invalid relation (eg A is north of B & B is north of A){}{  	(        	(PlaceDecleration(locations) 	//Take either a place deceleration (eg I see the A)    	| PlaceRelation(locations) ) 	//Or a place relation (eg the A is north of the B)    	< LINETERMINATOR > 				//Followed by a line terminator (eg .)    	{    	}  	)+  	< EOF >}void PlaceDecleration(java.util.HashMap<String, Location > locations) throws PlaceAlreadyDefinedException:{  	String placeName;}{  	"I see "  	placeName = PlaceDefinition()  	{    	if(locations.containsKey(placeName))    	{			throw new PlaceAlreadyDefinedException(placeName);    	}    	else    	{			locations.put(placeName, new Location(placeName));		}  	}  	(    	< LISTSEPERATOR >    	placeName = PlaceDefinition()    	{			locations.put(placeName, new Location(placeName));    	}  	)*  }void PlaceRelation(java.util.HashMap<String, Location> definedLocations) throws UndefinedLocationException,																				SelfReferentialRelationException,																				IncorrectLocationException :{  	String placeA;  	String placeB;  	ArrayList<String> aLocations = null;  	ArrayList<String> bLocations = null;  	Token directionToken;}{  	placeA = PlaceDefinition() (" is " //take either one place followed by is   			| aLocations = MultiplePlaceListRelation(definedLocations) " are ") //or multiple followed by are  			directionToken = < DIRECTION > //Take a direction  			" of " placeB = PlaceDefinition() (bLocations = MultiplePlaceListRelation(definedLocations))? //of one or more places  	{  	  	// Initalise (if required) a and b lists and add at least one place to them  	  	if(aLocations == null)  	  	{			aLocations = new ArrayList<String>();  	  	}  	  	aLocations.add(placeA);  	  	if(bLocations == null)  	  	{			bLocations = new ArrayList<String>();  	  	}  	  	bLocations.add(placeB);		//Check all locations exist in list A  	  	for(String location : aLocations)  	  	{			if(!definedLocations.containsKey(location.toLowerCase()))			{				throw new UndefinedLocationException(location);			}  	  	}		//Check all locations exist in list B		for(String location : bLocations)		{			if(!definedLocations.containsKey(location.toLowerCase()))			{				throw new UndefinedLocationException(location);			}		}  	  	 		System.out.println("All locations found");		//Check to see if any location is in both lists		for(String aLocation : aLocations)		{		  	for(String bLocation : bLocations)		  	{				if(aLocation.equals(bLocation))				{					throw new SelfReferentialRelationException(aLocation);				}		  	}		}		System.out.println("No location in both lists");		//Since all the locations are defined, we can now find them in our map of locations		ArrayList<Location> locationListA = new ArrayList<Location>();		ArrayList<Location> locationListB = new ArrayList<Location>();		for(String aLocation : aLocations)		{			locationListA.add(definedLocations.get(aLocation));		}		for(String bLocation : bLocations)		{			locationListB.add(definedLocations.get(bLocation));		} 		//Calculate the location entered by the user		Direction dir = Direction.valueOf(directionToken.image);		System.out.println(dir.toString());		//Define a location between all of the locations in List A with all of the locations in list B		Location.DefineRelation(locationListA, locationListB, dir);	}  }//Read multiple places and throw an error if any one of them not foundArrayList<String> MultiplePlaceListRelation(java.util.HashMap locations) throws UndefinedLocationException :{	String placeName;	ArrayList<String> places = new ArrayList<String>();}{  	(    	< LISTSEPERATOR >    	placeName = PlaceDefinition()    	{			if(!locations.containsKey(placeName.toLowerCase()))			{				throw new UndefinedLocationException(placeName);			}			else			{				places.add(placeName);			}    	}  	)+  	{  	  	return places;  	}}SKIP:{ 	"\r" | "\n" | "\r\n" | " "} TOKEN :{  	< DIRECTION : "NORTH" | "SOUTH" | "EAST" | "WEST" >}TOKEN :{  	< LISTSEPERATOR : ", " | " and " >}String PlaceDefinition() :{ 	Token t;  	String placeName = "";}{  	< PLACESTART >  	(  		(			t = < PLACECHAR > 			{				placeName += t.image; 			}		)+		|		(		 	< COMPLEXPLACESTART > (  				t = < COMPLEXPLACECHAR >				{			  		placeName += t.image;				}						)+		< COMPLEXPLACEEND > )	)	{	  return placeName.toLowerCase();	}}  TOKEN :{ 	< PLACESTART : "THE " > }TOKEN: //read a character or a space for a place name{	< PLACECHAR:  ( ["a" - "z"] | " ")  >}< READING_COMPLEX > TOKEN: //read a character or a space for a place name{	< COMPLEXPLACECHAR:  ( ["a" - "z"] | " ")  >}TOKEN:  //marks the begining of a place name with a keyword in{	< COMPLEXPLACESTART : "[" > : READING_COMPLEX}< READING_COMPLEX > TOKEN: //marks the end of a place name with a keyword in{	< COMPLEXPLACEEND : "]"  > :  DEFAULT }TOKEN :{  	< LINETERMINATOR : "." | ";" >}
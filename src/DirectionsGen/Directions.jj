options {	STATIC = false;	IGNORE_CASE = true;	DEBUG_PARSER = true;
}PARSER_BEGIN(Directions)	class Directions	{	  	static int i = 0;		public static void main(String[] args) throws ParseException, UndefinedLocationException, PlaceAlreadyDefinedException		{		  	java.util.HashMap<String, Location> locations = new java.util.HashMap<String, Location>(); 			Directions parser = new Directions(System.in);			try			{				parser.Start(locations);			}			catch(ParseException e)			{				System.err.println("[PARSING ERROR]" + e.getMessage());			}			catch(TokenMgrError e)			{				System.err.println("[LEXING ERROR] " + e.getMessage());			}			catch(UndefinedLocationException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.locationName + "\" not defined");			}			catch(PlaceAlreadyDefinedException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.locationName + "\" defined already");			}			catch(SelfReferentialRelationException e)			{				System.err.println("[PARSING ERROR] Cannot perform self referential relation with location \"" + e.locationName + "\""); 			}			catch(IncorrectLocationException e)			{				System.err.println("[PARSING ERROR] Location cannot be both north and south of a location");				}			System.out.print("[");			for(String locationName : locations.keySet())			{				System.out.print(locationName +", ");			}			System.out.print("]");		}	}	class Location	{	  	public String locationName;		java.util.HashMap<String, Location > northLocations;		java.util.HashMap<String, Location > southLocations;		java.util.HashMap<String, Location > westLocations;		java.util.HashMap<String, Location > eastLocations;	  	public Location(String locName)	  	{		    locationName = locName;		    northLocations = new java.util.HashMap<String, Location >();		    westLocations = new java.util.HashMap<String, Location >();		    eastLocations = new java.util.HashMap<String, Location >();		    southLocations = new java.util.HashMap<String, Location >();	  	}		public void AddNorthLocation(Location location) throws IncorrectLocationException		{			if(southLocations.containsKey(location.locationName))			{				throw new IncorrectLocationException(this, location, Direction.north);			}			else			{				northLocations.put(location.locationName, location);			}		}			public void AddSouthLocation(Location location) throws IncorrectLocationException		{			if(northLocations.containsKey(location.locationName))			{				throw new IncorrectLocationException(this, location, Direction.south);			}			else			{				southLocations.put(location.locationName, location);			}		}	}	class UndefinedLocationException extends Exception	{	  	public String locationName;		public UndefinedLocationException(String locationName)		{			  super();			  this.locationName = locationName;		}	}	class PlaceAlreadyDefinedException extends Exception	{		public String locationName;		public PlaceAlreadyDefinedException(String locationName)		{		  	super();		  	this.locationName = locationName;		}		}	class IncorrectLocationException extends Exception	{		public IncorrectLocationException(Location aLocation, Location bLocation, Direction direction)		{		}		}	class SelfReferentialRelationException extends Exception	{	  	public String locationName;		public SelfReferentialRelationException(String location)		{			locationName = location;		}	}	enum Direction	{		north,		south,		east,		west	}	PARSER_END(Directions)void Start(java.util.HashMap<String, Location> locations) throws UndefinedLocationException,																	PlaceAlreadyDefinedException,																	SelfReferentialRelationException,																	IncorrectLocationException :{}{  	(        	(PlaceDecleration(locations) | PlaceRelation(locations) ) < LINETERMINATOR >    	{    	}  	)+  	< EOF >}void PlaceDecleration(java.util.HashMap<String, Location > locations) throws PlaceAlreadyDefinedException:{  	String placeName;}{  	"I see "  	placeName = PlaceDefinition()  	{    	if(locations.containsKey(placeName))    	{			throw new PlaceAlreadyDefinedException(placeName);    	}    	else    	{			locations.put(placeName, new Location(placeName));		}  	}  	(    	< LISTSEPERATOR >    	placeName = PlaceDefinition()    	{			locations.put(placeName, new Location(placeName));    	}  	)*  }void PlaceRelation(java.util.HashMap<String, Location> definedLocations) throws UndefinedLocationException,																				SelfReferentialRelationException,																				IncorrectLocationException :{  	String placeA;  	String placeB;  	Token directionToken;}{  	placeA = PlaceDefinition() (" is "  							| MultiplePlaceListRelation(definedLocations) " are ")  	directionToken = < DIRECTION > " of " placeB = PlaceDefinition() (MultiplePlaceListRelation(definedLocations))?  	{   		if(!definedLocations.containsKey(placeA.toLowerCase()) || !definedLocations.containsKey(placeB.toLowerCase()))  		{  			System.out.println("Location not found");  	  		if(!definedLocations.containsKey(placeA.toLowerCase()))  	  		{    	  			throw new UndefinedLocationException(placeA);  	  		}  	  		else  	  		{				throw new UndefinedLocationException(placeB);  	  		}  		}  		else  		{  	 		System.out.println("Both locations found");  	 		if(placeA.toLowerCase().equals(placeB.toLowerCase()))  	 		{				throw new SelfReferentialRelationException(placeA);  	 		}  	 		else  	 		{				Direction dir = Direction.valueOf(directionToken.image);				System.out.println(dir.toString());				switch(dir)				{					case north:						Location locA = definedLocations.get(placeA);						Location locB = definedLocations.get(placeB);						locA.AddNorthLocation(locB);						locB.AddSouthLocation(locA);					break;					case south:					break;					case east:					break;					case west:					break;				}    	 		}		}	}  }//Read multiple places and throw an error if any one of them not foundvoid MultiplePlaceListRelation(java.util.HashMap locations) throws UndefinedLocationException :{	String placeName;}{  	(    	< LISTSEPERATOR >    	placeName = PlaceDefinition()    	{			if(!locations.containsKey(placeName.toLowerCase()))			{				throw new UndefinedLocationException(placeName);			}    	}  	)+}SKIP:{ 	"\r" | "\n" | "\r\n" | " "} TOKEN :{  	< DIRECTION : "NORTH" | "SOUTH" | "EAST" | "WEST" >}TOKEN :{  	< LISTSEPERATOR : ", " | " and " >}String PlaceDefinition() :{ 	Token t;  	String placeName = "";}{  	< PLACESTART >  	(  		(			t = < PLACECHAR > 			{				placeName += t.image; 			}		)+		|		(		 	< COMPLEXPLACESTART > (  				t = < COMPLEXPLACECHAR >				{			  		placeName += t.image;				}						)+		< COMPLEXPLACEEND > )	)	{	  return placeName.toLowerCase();	}}  TOKEN :{ 	< PLACESTART : "THE " > }TOKEN: //read a character or a space for a place name{	< PLACECHAR:  ( ["a" - "z"] | " ")  >}< READING_COMPLEX > TOKEN: //read a character or a space for a place name{	< COMPLEXPLACECHAR:  ( ["a" - "z"] | " ")  >}TOKEN:  //marks the begining of a place name with a keyword in{	< COMPLEXPLACESTART : "[" > : READING_COMPLEX}< READING_COMPLEX > TOKEN: //marks the end of a place name with a keyword in{	< COMPLEXPLACEEND : "]"  > :  DEFAULT }TOKEN :{  	< LINETERMINATOR : "." | ";" >}
options {	STATIC = false;	IGNORE_CASE = true;	DEBUG_PARSER = true;
}PARSER_BEGIN(Directions)	import java.util.*;	class Directions	{	  	static int i = 0;		public static void main(String[] args) throws ParseException, UndefinedLocationException, PlaceAlreadyDefinedException		{		  	java.util.HashMap<String, Location> locations = new java.util.HashMap<String, Location>(); 			Directions parser = new Directions(System.in);			try			{				parser.Start(locations);			}			catch(ParseException e)			{				System.err.println("[PARSING ERROR]" + e.getMessage());			}			catch(TokenMgrError e)			{				System.err.println("[LEXING ERROR] " + e.getMessage());			}			catch(UndefinedLocationException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.locationName + "\" not defined");			}			catch(PlaceAlreadyDefinedException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.locationName + "\" defined already");			}			catch(SelfReferentialRelationException e)			{				System.err.println("[PARSING ERROR] Cannot perform self referential relation with location \"" + e.locationName + "\""); 			}			catch(IncorrectLocationException e)			{				System.err.println("[PARSING ERROR] Location cannot be both north and south of a location");				}			catch(TransativePlaceRelationContradictionException e)			{				System.err.println("[PARSING ERROR] Location \"" + e.wrongLocation + "\" is defined (transitively) to be both north and south of \""+e.startLocation +"\"");			}			System.out.print("[");			for(String locationName : locations.keySet())			{				System.out.print(locationName +", ");			}			System.out.print("]");		}	}	class Location	{	  	public String locationName;		java.util.HashMap<String, Location > northLocations;		java.util.HashMap<String, Location > southLocations;		java.util.HashMap<String, Location > westLocations;		java.util.HashMap<String, Location > eastLocations;	  	public Location(String locName)	  	{		    locationName = locName;		    northLocations = new java.util.HashMap<String, Location >(); //all locations defined to be north of this location either directly or transitively		    westLocations = new java.util.HashMap<String, Location >();		    eastLocations = new java.util.HashMap<String, Location >();		    southLocations = new java.util.HashMap<String, Location >();	  	}		public void AddNorthLocation(Location location) throws IncorrectLocationException, TransativePlaceRelationContradictionException		{			if(southLocations.containsKey(location.locationName))			{				throw new IncorrectLocationException(this, location, Direction.north);			}			else			{			  	HashMap<String, Location> impliedNorthernLocations = location.GetAllLocations(Direction.north);				northLocations.putAll(impliedNorthernLocations);			  					/*for(Map.Entry<String, Location> locationEntry : impliedNorthernLocations.entrySet())				{				  	System.out.println("Adding north location - " + locationEntry.getKey() + " to location " + locationName);					if(locationEntry.getKey() != location.locationName) //we have already checked the location we are specifically checking					{						if(southLocations.containsKey(locationEntry.getKey()))						{							throw new TransativePlaceRelationContradictionException(locationName, locationEntry.getKey());						}						else						{						  	northLocations.put(locationEntry.getKey(), locationEntry.getValue());						} 					}					else					{						northLocations.put(locationEntry.getKey(), locationEntry.getValue());					}				}			}*/		}			public void AddSouthLocation(Location location) throws IncorrectLocationException, TransativePlaceRelationContradictionException		{			if(northLocations.containsKey(location.locationName))			{				throw new IncorrectLocationException(this, location, Direction.south);			}			else			{			  	HashMap<String, Location> impliedSouthernLocations = location.GetAllLocations(Direction.south);			  	southLocations.putAll(impliedSouthernLocations);				/*for(Map.Entry<String, Location> locationEntry : impliedSouthernLocations.entrySet())				{				  	System.out.println("Adding south location - " + locationEntry.getKey() + " to location " + locationName);					if(locationEntry.getKey() != location.locationName) //we have already checked the location we are specifically checking					{						if(northLocations.containsKey(locationEntry.getKey()))						{							throw new TransativePlaceRelationContradictionException(locationName, locationEntry.getKey());						}						else						{						  	southLocations.put(locationEntry.getKey(), locationEntry.getValue());						} 					}					else					{						southLocations.put(locationEntry.getKey(), locationEntry.getValue());					}				}*/			}		}		public void AddEastLocation(Location location) throws IncorrectLocationException		{		 	if(westLocations.containsKey(location.locationName))		 	{				throw new IncorrectLocationException(this, location, Direction.east);			}			else			{				eastLocations.putAll(location.GetAllLocations(Direction.east));				}		}		public void AddWestLocation(Location location) throws IncorrectLocationException		{		 	if(eastLocations.containsKey(location.locationName))		 	{				throw new IncorrectLocationException(this, location, Direction.west);			}			else			{				westLocations.putAll(location.GetAllLocations(Direction.west));				}		}		//Return all the locations (including this one) in a given direction including transitivity		public HashMap<String, Location> GetAllLocations(Direction direction)		{			HashMap<String, Location> locationsInDirection = new HashMap<String, Location>();			locationsInDirection.put(locationName, this);			switch(direction)			{				case north:					for(Location northLocation : northLocations.values())					{						locationsInDirection.putAll(northLocation.GetAllLocations(direction));					}				break;				case south:					for(Location southLocation : southLocations.values())					{						locationsInDirection.putAll(southLocation.GetAllLocations(direction));					}				break;				case east:					for(Location eastLocation : eastLocations.values())					{						locationsInDirection.putAll(eastLocation.GetAllLocations(direction));					}				break;				case west:					for(Location westLocation : westLocations.values())					{						locationsInDirection.putAll(westLocation.GetAllLocations(direction));					}				break;			}			return locationsInDirection;		} 		public static void DefineRelation(ArrayList<Location> locationAs, ArrayList<Location> locationBs, Direction relation)		{			switch(relation)			{				case north:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is north of bLocation							aLocation.AddSouthLocation(bLocation);							bLocation.AddNorthLocation(aLocation);						}					}				break;				case south:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is south of bLocation							aLocation.AddNorthLocation(bLocation);							bLocation.AddSouthLocation(aLocation);						}					}				break;				case east:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is east of bLocation							aLocation.AddWestLocation(bLocation);							bLocation.AddEastLocation(aLocation);						}					}				break;				case west:					for(Location aLocation : locationAs) //for all of the A locations					{						for(Location bLocation : locationBs) //for all of the B locations						{							//aLocation is west of bLocation							aLocation.AddEastLocation(bLocation);							bLocation.AddWestLocation(aLocation);						}					}				break;			}		}	}	class UndefinedLocationException extends Exception	{	  	public String locationName;		public UndefinedLocationException(String locationName)		{			  super();			  this.locationName = locationName;		}	}	class PlaceAlreadyDefinedException extends Exception	{		public String locationName;		public PlaceAlreadyDefinedException(String locationName)		{		  	super();		  	this.locationName = locationName;		}		}	class IncorrectLocationException extends Exception	{		public IncorrectLocationException(Location aLocation, Location bLocation, Direction direction)		{		}		}	class SelfReferentialRelationException extends Exception	{	  	public String locationName;		public SelfReferentialRelationException(String location)		{			locationName = location;		}	}	class TransativePlaceRelationContradictionException extends Exception	{	  	public String startLocation;	  	public String wrongLocation;	  	public TransativePlaceRelationContradictionException(String placeA, String placeB)	  	{			startLocation = placeA;			wrongLocation = placeB;	  	}	}	enum Direction	{		north,		south,		east,		west	}	PARSER_END(Directions)void Start(java.util.HashMap<String, Location> locations) throws UndefinedLocationException,																	PlaceAlreadyDefinedException,																	SelfReferentialRelationException,																	IncorrectLocationException,																	TransativePlaceRelationContradictionException :{}{  	(        	(PlaceDecleration(locations) | PlaceRelation(locations) ) < LINETERMINATOR >    	{    	}  	)+  	< EOF >}void PlaceDecleration(java.util.HashMap<String, Location > locations) throws PlaceAlreadyDefinedException:{  	String placeName;}{  	"I see "  	placeName = PlaceDefinition()  	{    	if(locations.containsKey(placeName))    	{			throw new PlaceAlreadyDefinedException(placeName);    	}    	else    	{			locations.put(placeName, new Location(placeName));		}  	}  	(    	< LISTSEPERATOR >    	placeName = PlaceDefinition()    	{			locations.put(placeName, new Location(placeName));    	}  	)*  }void PlaceRelation(java.util.HashMap<String, Location> definedLocations) throws UndefinedLocationException,																				SelfReferentialRelationException,																				IncorrectLocationException,																				TransativePlaceRelationContradictionException :{  	String placeA;  	String placeB;  	Token directionToken;}{  	placeA = PlaceDefinition() (" is "  							| MultiplePlaceListRelation(definedLocations) " are ")  	directionToken = < DIRECTION > " of " placeB = PlaceDefinition() (MultiplePlaceListRelation(definedLocations))?  	{   		if(!definedLocations.containsKey(placeA.toLowerCase()) || !definedLocations.containsKey(placeB.toLowerCase()))  		{  			System.out.println("Location not found");  	  		if(!definedLocations.containsKey(placeA.toLowerCase()))  	  		{    	  			throw new UndefinedLocationException(placeA);  	  		}  	  		else  	  		{				throw new UndefinedLocationException(placeB);  	  		}  		}  		else  		{  	 		System.out.println("Both locations found");  	 		if(placeA.toLowerCase().equals(placeB.toLowerCase()))  	 		{				throw new SelfReferentialRelationException(placeA);  	 		}  	 		else  	 		{				Direction dir = Direction.valueOf(directionToken.image);				System.out.println(dir.toString());				Location locA = definedLocations.get(placeA);				Location locB = definedLocations.get(placeB);				switch(dir)				{					case north:						locA.AddSouthLocation(locB);						locB.AddNorthLocation(locA);					break;											case south:						locA.AddNorthLocation(locB);						locB.AddSouthLocation(locA);					break;					case east:					break;					case west:					break;				}    	 		}		}	}  }//Read multiple places and throw an error if any one of them not foundvoid MultiplePlaceListRelation(java.util.HashMap locations) throws UndefinedLocationException :{	String placeName;}{  	(    	< LISTSEPERATOR >    	placeName = PlaceDefinition()    	{			if(!locations.containsKey(placeName.toLowerCase()))			{				throw new UndefinedLocationException(placeName);			}    	}  	)+}SKIP:{ 	"\r" | "\n" | "\r\n" | " "} TOKEN :{  	< DIRECTION : "NORTH" | "SOUTH" | "EAST" | "WEST" >}TOKEN :{  	< LISTSEPERATOR : ", " | " and " >}String PlaceDefinition() :{ 	Token t;  	String placeName = "";}{  	< PLACESTART >  	(  		(			t = < PLACECHAR > 			{				placeName += t.image; 			}		)+		|		(		 	< COMPLEXPLACESTART > (  				t = < COMPLEXPLACECHAR >				{			  		placeName += t.image;				}						)+		< COMPLEXPLACEEND > )	)	{	  return placeName.toLowerCase();	}}  TOKEN :{ 	< PLACESTART : "THE " > }TOKEN: //read a character or a space for a place name{	< PLACECHAR:  ( ["a" - "z"] | " ")  >}< READING_COMPLEX > TOKEN: //read a character or a space for a place name{	< COMPLEXPLACECHAR:  ( ["a" - "z"] | " ")  >}TOKEN:  //marks the begining of a place name with a keyword in{	< COMPLEXPLACESTART : "[" > : READING_COMPLEX}< READING_COMPLEX > TOKEN: //marks the end of a place name with a keyword in{	< COMPLEXPLACEEND : "]"  > :  DEFAULT }TOKEN :{  	< LINETERMINATOR : "." | ";" >}